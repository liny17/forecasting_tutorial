---
title: "Tutorial"
author: "Jamey McDowell and Steffani Gomez"
date: "March 13, 2018"
output: html_notebook
---

# {.tabset .tabset-fade}

## Introduction

This tutorial is for those already familiar with using dataframes in R.  This includes familiarity with subsetting and the library <code>dplyr</code> for data manipulation.

In R there are two primary time series objects that are used.  These objects are either <code>ts</code> or <code>xts</code>.  

For the purpose of this tutorial, we are going to focus on using <code>ts</code> to create time-series objects.  R preloads this function through the <code>stats</code> package.

### Making a Univariate Time-Series Objects

Columns are variables, observations are rows.  You can view a time-series object the same way as a matrix or dataframe.  At its core, a time-series object is a vector (univariate) or matrix (multivariate).  Dataframes are implicitly converted to matrices before they are actually converted to a time-series object.

Consider, for example, loading the co2_ts.csv file:

```{r}
co2_df <- read.csv("co2_ts.csv")

class(co2_df)
```

When first loaded, note that R saves the file as a data frame.  Therefore we must convert the data frame to a time series object.  To make a time series object, we need to know the start, end, and frequency for our data.  For this csv file, the data is already sorted for us.  If this were not the case, we could use the <code>arrange</code> function from <code>dplyr</code> package to sort the data instead.  Because we already have the month number in one column and the year column in another, we can sort the data accordingly:

```{r, output = FALSE}
library(dplyr)

co2_df <- co2_df %>%
  arrange(Year, Month)
```

By visually inspecting this newly arranged data, we see that the dataset runs from <code>05-1974</code> to <code>09-1987</code>.  Therefore we will specify the start and end dates accordingly when making the time series objects.  Because we are dealing with monthly data, we set the frequency argument to 12.

We also see that we are dealing with univariate data.  Therefore when making the time series object, we only need to take the <code>CO2</code> column from the data frame.

```{r}
co2_ts <- ts(co2_df$CO2, start = c(1974, 5), end = c(1987, 9), frequency = 12)
```

This code took only the <code>CO2</code> column from our original data frame since this is the only column that contains data not pertaining to the date.

Our new object is of type <code>ts</code>.

```{r}
class(co2_ts)
```

### Making a Multivariate Time Series Object

Will fill this in once we have a multivariate time series set to work with.

## Libraries

<<<<<<< HEAD
The main library used for forecasting in R is (surprise) the <code>forecast</code> package!

```{r}
library(forecast)
```

With this package come several useful functions.  The ones that we are going to discuss in this tutorial include ... The full uses of this package can be found at https://cran.r-project.org/web/packages/forecast/forecast.pdf.

## Messy Data Examples

Consider the ch1_demodat.csv file from class on March 15.  This data has both missing values and a difficult-to-parse <code>dtdate</code> variable.  We will first work on the <code>dtdate</code> variable by using the <code>strptime</code> function.

```{r}
ch1_demodat <- read.csv("ch1_demodat.csv")

ch1_demodat$time <- strptime(ch1$dtdate, format = '%d%b%Y:%T')
```

Note the weird format argument.  Look more at the <code>strptime</code> function for more informration on how I chose this by typing "?strptime" in the console.

The primary reasoning here is that R stores time variables as either a  <code>POSIXlt</code> object for 

=======
There is a main libraries in R for forecasting. This is the *sarima* library, which handles ARMA and ARIMA models for us, allowing us to set parameters easily.

```{r}
library(sarima)
```

>>>>>>> 08457bf5dbd98d5a5f7bde0d8d01b72ecdf24738

## EDA Tutorial

We can use the basic plot function to visualize the data set:

```{r}
plot(co2_ts)
```

```{r}
Acf(co2_ts)
```


## Seasonality

## Models

This is an example of forecasting in R.

```{r}
library(dplyr)
solarpv_df <- read.csv("solarpv.csv")

# using the lapply function to look at the data type of each variable, and we see that our date is not in 
# a date format 
lapply(solarpv_df, class)

# to transform, we are going to need the as.Date() function 
solarpv_df$EDT <- as.Date(solarpv_df$EDT, "%a, %d %b %Y")
lapply(solarpv_df, class)

# https://www.statmethods.net/input/dates.html
# now we can see we transformed the date properly


# here we plot the series, a univariate series as we can see
plot(y=solarpv_df$kW_Gen, x=solarpv_df$EDT, type='l')

acf(solarpv_df$kW_Gen, lag.max = 24)
pacf(solarpv_df$kW_Gen, lag.max = 24)

# autocorrelation white noise test
whiteNoiseTest(autocorrelations(solarpv_df$kW_Gen, maxlag = 24), h0 = "iid", nlags = c(6,12,18,24), x = x, method = "LjungBox")

mean(solarpv_df$kW_Gen)
sd(solarpv_df$kW_Gen)
length(solarpv_df$kW_Gen)


#estimate arima model
mod.1 <- arima(solarpv_df$kW_Gen, order=c(1,0,0), method = "ML")
mod.2 <- sarima(solarpv_df$kW_Gen, p = 1, d = 0, q = 0)
mod.1
mod.2
 
#diagnose arima model
acf(mod.1$residuals)
pacf(mod.1$residuals)
Box.test(mod.1$residuals)

```


## Model Evaluation



